//final static boolean PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG = true;
final static boolean PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG = false;

//final static boolean PRINT_ROI_OBJECTS_GHOST_ISSUE_DBG = true;
final static boolean PRINT_ROI_OBJECTS_GHOST_ISSUE_DBG = false;

//final static boolean PRINT_ROI_DATA_ALL_DBG = true;
final static boolean PRINT_ROI_DATA_ALL_DBG = false;
final static boolean PRINT_ROI_DATA_ALL_ERR = true;
//final static boolean PRINT_ROI_DATA_ALL_ERR = false;

//final static boolean PRINT_ROI_DATA_SETTINGS_DBG = true;
final static boolean PRINT_ROI_DATA_SETTINGS_DBG = false;
//final static boolean PRINT_ROI_DATA_SETTINGS_ERR = true;
final static boolean PRINT_ROI_DATA_SETTINGS_ERR = false;

//final static boolean PRINT_ROI_DATA_SETUP_DBG = true;
final static boolean PRINT_ROI_DATA_SETUP_DBG = false;
//final static boolean PRINT_ROI_DATA_SETUP_ERR = true;
final static boolean PRINT_ROI_DATA_SETUP_ERR = false;

//final static boolean PRINT_ROI_DATA_CONSTRUCTOR_DBG = true;
final static boolean PRINT_ROI_DATA_CONSTRUCTOR_DBG = false;
//final static boolean PRINT_ROI_DATA_CONSTRUCTOR_ERR = true;
final static boolean PRINT_ROI_DATA_CONSTRUCTOR_ERR = false;

//final static boolean PRINT_ROI_DATA_SET_TIME_STAMP_DBG = true;
final static boolean PRINT_ROI_DATA_SET_TIME_STAMP_DBG = false;
//final static boolean PRINT_ROI_DATA_SET_TIME_STAMP_ERR = true;
final static boolean PRINT_ROI_DATA_SET_TIME_STAMP_ERR = false;

//final static boolean PRINT_ROI_DATA_SET_ANGLE_STEP_DBG = true;
final static boolean PRINT_ROI_DATA_SET_ANGLE_STEP_DBG = false;
//final static boolean PRINT_ROI_DATA_SET_ANGLE_STEP_ERR = true;
final static boolean PRINT_ROI_DATA_SET_ANGLE_STEP_ERR = false;

//final static boolean PRINT_ROI_DATA_CLEAR_POINTS_DBG = true;
final static boolean PRINT_ROI_DATA_CLEAR_POINTS_DBG = false;
//final static boolean PRINT_ROI_DATA_CLEAR_POINTS_ERR = true;
final static boolean PRINT_ROI_DATA_CLEAR_POINTS_ERR = false;

//final static boolean PRINT_ROI_DATA_ADD_POINT_DBG = true;
final static boolean PRINT_ROI_DATA_ADD_POINT_DBG = false;
//final static boolean PRINT_ROI_DATA_ADD_POINT_ERR = true;
final static boolean PRINT_ROI_DATA_ADD_POINT_ERR = false;

//final static boolean PRINT_ROI_DATA_DETECT_OBJECTS_DBG = true;
final static boolean PRINT_ROI_DATA_DETECT_OBJECTS_DBG = false;
//final static boolean PRINT_ROI_DATA_DETECT_OBJECTS_ERR = true;
final static boolean PRINT_ROI_DATA_DETECT_OBJECTS_ERR = false;

//final static boolean PRINT_ROI_DATA_DRAW_OBJECTS_DBG = true;
final static boolean PRINT_ROI_DATA_DRAW_OBJECTS_DBG = false;
//final static boolean PRINT_ROI_DATA_DRAW_OBJECTS_ERR = true;
final static boolean PRINT_ROI_DATA_DRAW_OBJECTS_ERR = false;

//final static boolean PRINT_ROI_DATA_DRAW_OBJECT_INFO_DBG = true;
final static boolean PRINT_ROI_DATA_DRAW_OBJECT_INFO_DBG = false;
//final static boolean PRINT_ROI_DATA_DRAW_OBJECT_INFO_ERR = true;
final static boolean PRINT_ROI_DATA_DRAW_OBJECT_INFO_ERR = false;

//final static boolean PRINT_ROI_DATA_GET_OBJECT_INDEX_OVER_SCR_XY_DBG = true;
final static boolean PRINT_ROI_DATA_GET_OBJECT_INDEX_OVER_SCR_XY_DBG = false;
//final static boolean PRINT_ROI_DATA_GET_OBJECT_INDEX_OVER_SCR_XY_ERR = true;
final static boolean PRINT_ROI_DATA_GET_OBJECT_INDEX_OVER_SCR_XY_ERR = false;

//final static boolean PRINT_ROI_DATA_CHECK_SCR_XY_OVER_OBJECTS_DBG = true;
final static boolean PRINT_ROI_DATA_CHECK_SCR_XY_OVER_OBJECTS_DBG = false;
//final static boolean PRINT_ROI_DATA_CHECK_SCR_XY_OVER_OBJECTS_ERR = true;
final static boolean PRINT_ROI_DATA_CHECK_SCR_XY_OVER_OBJECTS_ERR = false;

//final static boolean PRINT_ROI_DATA_CHECK_SCR_XY_OVER_OBJECT_DBG = true;
final static boolean PRINT_ROI_DATA_CHECK_SCR_XY_OVER_OBJECT_DBG = false;
//final static boolean PRINT_ROI_DATA_CHECK_SCR_XY_OVER_OBJECT_ERR = true;
final static boolean PRINT_ROI_DATA_CHECK_SCR_XY_OVER_OBJECT_ERR = false;

//final static boolean PRINT_ROI_DATA_CHECK_OBJECTS_MI_OVERLAPPED_DBG = true;
final static boolean PRINT_ROI_DATA_CHECK_OBJECTS_MI_OVERLAPPED_DBG = false;
//final static boolean PRINT_ROI_DATA_CHECK_OBJECTS_MI_OVERLAPPED_ERR = true;
final static boolean PRINT_ROI_DATA_CHECK_OBJECTS_MI_OVERLAPPED_ERR = false;

//final static boolean PRINT_ROI_DATA_CHECK_MI_XY_OVER_OBJECT_DBG = true;
final static boolean PRINT_ROI_DATA_CHECK_MI_XY_OVER_OBJECT_DBG = false;
//final static boolean PRINT_ROI_DATA_CHECK_MI_XY_OVER_OBJECT_ERR = true;
final static boolean PRINT_ROI_DATA_CHECK_MI_XY_OVER_OBJECT_ERR = false;

//final static boolean PRINT_ROI_DATA_ADD_OBJECTS_DBG = true;
final static boolean PRINT_ROI_DATA_ADD_OBJECTS_DBG = false;
//final static boolean PRINT_ROI_DATA_ADD_OBJECTS_ERR = true;
final static boolean PRINT_ROI_DATA_ADD_OBJECTS_ERR = false;

//final static boolean PRINT_ROI_DATA_ADD_OBJECT_DBG = true;
final static boolean PRINT_ROI_DATA_ADD_OBJECT_DBG = false;
//final static boolean PRINT_ROI_DATA_ADD_OBJECT_ERR = true;
final static boolean PRINT_ROI_DATA_ADD_OBJECT_ERR = false;

//final static boolean PRINT_ROI_DATA_PRINT_POINTS_DBG = true;
final static boolean PRINT_ROI_DATA_PRINT_POINTS_DBG = false;
//final static boolean PRINT_ROI_DATA_PRINT_POINTS_ERR = true;
final static boolean PRINT_ROI_DATA_PRINT_POINTS_ERR = false;

//final static boolean PRINT_ROI_DATA_SAVE_EVENT_DBG = true;
final static boolean PRINT_ROI_DATA_SAVE_EVENT_DBG = false;
//final static boolean PRINT_ROI_DATA_SAVE_EVENT_ERR = true;
final static boolean PRINT_ROI_DATA_SAVE_EVENT_ERR = false;

static int ROI_OBJECT_MARKER_MARGIN = 10;

//static int ROI_OBJECT_DETECT_POINTS_DISTANCE_MAX = 10000; // = 1 meter
static int ROI_OBJECT_DETECT_POINTS_DISTANCE_MAX = 5000; // = 50 cm= 0.5 meter

static int ROI_OBJECT_DETECT_DIAMETER_MIN = 2000; // = 20 cm= 0.2 meter

static int ROI_OBJECT_DETECT_TIME_MIN = 500; // unit is milli-second(ms)

static int ROI_OBJECT_DETECT_KEEP_TIME = 2000; // unit is milli-second(ms)

static int ROI_OBJECT_NO_MARK_BIG_DIAMETER_MIN = 20000; // = 200cm= 2meter

static int PS_DATA_SAVE_EVENTS_DURATION_DEFAULT = 2000; // unit is ms.
static int PS_DATA_SAVE_EVENTS_DURATION_LIMIT = 30000; // unit is ms.

final static int PS_DATA_SAVE_EVENTS_DURATION_MIN = 1000; // 1 second
final static int PS_DATA_SAVE_EVENTS_DURATION_MAX = 60*1000; // 60 seconds = 1 minute

static ROI_Data ROI_Data_handle = null;

static boolean[] ROI_Data_draw_info_enabled = new boolean[PS_INSTANCE_MAX];
static int[] ROI_Data_draw_info_timer = new int[PS_INSTANCE_MAX];
static int[] ROI_Data_draw_info_x = new int[PS_INSTANCE_MAX];
static int[] ROI_Data_draw_info_y = new int[PS_INSTANCE_MAX];
static boolean[] ROI_Data_mouse_over = new boolean[PS_INSTANCE_MAX];
//static int[] ROI_Data_mouse_over_object_index = new int[PS_INSTANCE_MAX];
static boolean[] ROI_Data_mouse_pressed = new boolean[PS_INSTANCE_MAX];

void ROI_Data_setup() {
  if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_SETUP_DBG) println("ROI_Data_setup():Enter");

  if (PS_DATA_SAVE_EVENTS_DURATION_DEFAULT > PS_DATA_SAVE_EVENTS_DURATION_MAX)
    PS_DATA_SAVE_EVENTS_DURATION_DEFAULT = PS_DATA_SAVE_EVENTS_DURATION_MAX;
  if (PS_DATA_SAVE_EVENTS_DURATION_DEFAULT < PS_DATA_SAVE_EVENTS_DURATION_MIN)
    PS_DATA_SAVE_EVENTS_DURATION_DEFAULT = PS_DATA_SAVE_EVENTS_DURATION_MIN;
  //println("PS_DATA_SAVE_EVENTS_DURATION_DEFAULT="+PS_DATA_SAVE_EVENTS_DURATION_DEFAULT);

  if (PS_DATA_SAVE_EVENTS_DURATION_LIMIT > PS_DATA_SAVE_EVENTS_DURATION_MAX)
    PS_DATA_SAVE_EVENTS_DURATION_LIMIT = PS_DATA_SAVE_EVENTS_DURATION_MAX;
  if (PS_DATA_SAVE_EVENTS_DURATION_LIMIT < PS_DATA_SAVE_EVENTS_DURATION_MIN)
    PS_DATA_SAVE_EVENTS_DURATION_LIMIT = PS_DATA_SAVE_EVENTS_DURATION_MIN;
  if (PS_DATA_SAVE_EVENTS_DURATION_LIMIT < PS_DATA_SAVE_EVENTS_DURATION_DEFAULT)
    PS_DATA_SAVE_EVENTS_DURATION_LIMIT = PS_DATA_SAVE_EVENTS_DURATION_DEFAULT;
  //println("PS_DATA_SAVE_EVENTS_DURATION_LIMIT="+PS_DATA_SAVE_EVENTS_DURATION_LIMIT);

  /*
  // ROI_OBJECT_DETECT_KEEP_TIME must larger and equal with ROI_OBJECT_DETECT_TIME_MIN
  if (ROI_OBJECT_DETECT_KEEP_TIME < ROI_OBJECT_DETECT_TIME_MIN)
    ROI_OBJECT_DETECT_KEEP_TIME = ROI_OBJECT_DETECT_TIME_MIN;
  */

  for (int i = 0; i < PS_INSTANCE_MAX; i++)
  {
    ROI_Data_draw_info_enabled[i] = false;
    ROI_Data_draw_info_timer[i] = millis();
    ROI_Data_mouse_over[i] = false;
    //ROI_Data_mouse_over_object_index[i] = -1;
    ROI_Data_mouse_pressed[i] = false;
  }

  ROI_Data_handle = new ROI_Data();
  if (ROI_Data_handle == null)
  {
    if (PRINT_ROI_DATA_ALL_ERR || PRINT_ROI_DATA_SETUP_ERR) println("ROI_Data_setup():ROI_Data_handle=null");
    SYSTEM_logger.severe("ROI_Data_setup():ROI_Data_handle=null");
    return;
  }
}

void ROI_Data_mouse_pressed()
{
  for (int i = 0; i < PS_INSTANCE_MAX; i ++)
  {
    ROI_Data_mouse_pressed[i] = false;
    if (ROI_Data_mouse_over[i])
    {
      ROI_Data_mouse_pressed[i] = true;
      ROI_Data_draw_info_x[i] = mouseX;
      ROI_Data_draw_info_y[i] = mouseY;
      ROI_Data_draw_info_enabled[i] = true;
      if (ROI_Data_draw_info_enabled[i])
        ROI_Data_draw_info_timer[i] = millis();
    }
    else
    {
      int j;
      for (j = 0; j < PS_INSTANCE_MAX; j ++)
      {
        if (ROI_Data_mouse_over[j]) break;
      }
      if (j == PS_INSTANCE_MAX)
      {
        ROI_Data_draw_info_enabled[i] = false;
      }
    }
  }
}

void ROI_Data_mouse_released()
{
}

void ROI_Data_mouse_moved()
{
  for (int i = 0; i < PS_INSTANCE_MAX; i ++)
  {
/*
    int object_index;

    object_index = ROI_Data_handle.get_object_index_over_scr_xy(i, mouseX, mouseY, ROI_OBJECT_MARKER_MARGIN);
    if (object_index >= 0)
*/
    if (ROI_Data_handle.check_scr_xy_over_objects(i, mouseX, mouseY, ROI_OBJECT_MARKER_MARGIN))
    {
      ROI_Data_mouse_over[i] = true;
/*
      ROI_Data_mouse_over_object_index[i] = object_index;
*/
      if (ROI_Data_draw_info_enabled[i])
        ROI_Data_draw_info_timer[i] = millis();
    }
    else
    {
      ROI_Data_mouse_over[i] = false;
    }
  }
}

void ROI_Data_mouse_dragged()
{
  ROI_Data_mouse_moved();
}

// A ROI_Data class
class ROI_Data {
  ArrayList<ROI_Point_Data>[] points_new = new ArrayList[PS_INSTANCE_MAX];
  ArrayList<ROI_Object_Data>[] objects_last = new ArrayList[PS_INSTANCE_MAX];
  boolean[] time_stamp_init_done = new boolean[PS_INSTANCE_MAX];
  int[] time_stamp_new = new int[PS_INSTANCE_MAX];
  int[] time_stamp_last = new int[PS_INSTANCE_MAX];
  //long[] time_stamp_new = new long[PS_INSTANCE_MAX];
  float[] angle_step = new float[PS_INSTANCE_MAX];
  boolean[] detected_objects_are_same = new boolean[PS_INSTANCE_MAX];
  ROI_Detected_Objects[] detected_objects_last = new ROI_Detected_Objects[PS_INSTANCE_MAX];

  // Create the ROI_Data
  ROI_Data() {
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_CONSTRUCTOR_DBG) println("ROI_Data:constructor():Enter");
    for (int i = 0; i < PS_INSTANCE_MAX; i ++)
    {
      points_new[i] = new ArrayList<ROI_Point_Data>();
      objects_last[i] = new ArrayList<ROI_Object_Data>();
      detected_objects_last[i] = new ROI_Detected_Objects();
      detected_objects_are_same[i] = false;
      time_stamp_init_done[i] = false;
    }
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_CONSTRUCTOR_DBG) println("ROI_Data:constructor():Exit");
  }

  void set_time_stamp(int instance, int time_stamp) {
  //void set_time_stamp(int instance, long time_stamp) {
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_SET_TIME_STAMP_DBG) println("ROI_Data:set_time_stamp("+instance+"):");
    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_SET_TIME_STAMP_DBG) println("ROI_Data:set_time_stamp("+instance+"):"+"time_stamp="+time_stamp);
    // Check init time stamp.
    if (!time_stamp_init_done[instance]) {
      // Set last time stamp to new time stamp - 1.
      time_stamp_last[instance] = time_stamp - 1;
      time_stamp_new[instance] = time_stamp;
      time_stamp_init_done[instance] = true;
    }
    else {
      // Save last time stamp.
      time_stamp_last[instance] = time_stamp_new[instance];
      time_stamp_new[instance] = time_stamp;
    }
    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_SET_TIME_STAMP_DBG) println("ROI_Data:set_time_stamp("+instance+"):Exit");
  }

  void set_angle_step(int instance, float angle_step) {
  //void set_time_stamp(int instance, long time_stamp) {
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_SET_ANGLE_STEP_DBG) println("ROI_Data:set_angle_step("+instance+"):");
    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_SET_TIME_STAMP_DBG) println("ROI_Data:set_angle_step("+instance+"):"+"angle_step="+angle_step);
    this.angle_step[instance] = angle_step;
    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_SET_TIME_STAMP_DBG) println("ROI_Data:set_angle_step("+instance+"):Exit");
  }

  void clear_points(int instance) {
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_CLEAR_POINTS_DBG) println("ROI_Data:clear_points("+instance+"):Enter");
    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_CLEAR_POINTS_DBG) println("ROI_Data:clear_points("+instance+"):"+"points length="+points_new[instance].size());
    points_new[instance].clear();
    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_CLEAR_POINTS_DBG) println("ROI_Data:clear_points("+instance+"):Exit");
  }

  void clear_objects(int instance) {
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_CLEAR_POINTS_DBG) println("ROI_Data:clear_objects("+instance+"):Enter");
    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_CLEAR_POINTS_DBG) println("ROI_Data:clear_objects("+instance+"):"+"objects length="+objects_last[instance].size());
    objects_last[instance].clear();
    detected_objects_last[instance].clear();
    detected_objects_are_same[instance] = false;
    time_stamp_init_done[instance] = false;
    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_CLEAR_POINTS_DBG) println("ROI_Data:clear_objects("+instance+"):Exit");
  }

  void add_point(int instance, ArrayList<Integer> region_indexes, int mi_x, int mi_y, int scr_x, int scr_y) {
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_POINT_DBG) println("ROI_Data:add_points("+instance+"):Enter");
    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_POINT_DBG) println("ROI_Data:add_points("+instance+"):"+"region="+region+",mi_x="+mi_x+",mi_y="+mi_y+",scr_x="+scr_x+",scr_y="+scr_y);
    points_new[instance].add(new ROI_Point_Data(region_indexes, mi_x, mi_y, scr_x, scr_y));
    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_POINT_DBG) println("ROI_Data:add_points("+instance+"):Exit");
  }

  void detect_objects(int instance) {
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DETECT_OBJECTS_DBG) println("ROI_Data:detect_objects("+instance+"):Enter");

    // Check time stamp is changed.
    if (time_stamp_new[instance] == time_stamp_last[instance]) {
      // Don't need to process.
      return;
    }

    //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+")"+":time_stamp_new[instance]="+time_stamp_new[instance]);

    ArrayList<ROI_Object_Data> objects_new = new ArrayList<ROI_Object_Data>();

    //println("ROI_Data:detect_objects("+instance+"):"+"objects_new.size="+objects_new.size());
    //objects_new.clear();

    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DETECT_OBJECTS_DBG) println("ROI_Data:detect_objects("+instance+"):"+"objects_last["+instance+"]="+objects_last[instance]);
    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DETECT_OBJECTS_DBG) println("ROI_Data:detect_objects("+instance+"):"+"objects_new="+objects_new);

    // Get new objects.
    get_objects(
      objects_new,
      points_new[instance],
      time_stamp_new[instance],
      Regions_handle.get_regions_size_for_index(instance),
      angle_step[instance]);
    //Dbg_Time_logs_handle.add("ROI_Data:detect_objects("+instance+"):get_objects()");
    if (PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG || PRINT_ROI_OBJECTS_GHOST_ISSUE_DBG) println("ROI_Data:detect_objects("+instance+"):"+"get objects_new.size()="+objects_new.size());
    //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"get objects_new.size()="+objects_new.size());

    if (PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG || PRINT_ROI_OBJECTS_GHOST_ISSUE_DBG) println("ROI_Data:detect_objects("+instance+"):"+"init objects_last[instance].size()="+objects_last[instance].size());
    //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"init objects_last[instance].size()="+objects_last[instance].size());

    if (PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG) println("ROI_Data:detect_objects("+instance+")"+":time_stamp_new[instance]="+time_stamp_new[instance]);
    //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+")"+":time_stamp_new[instance]="+time_stamp_new[instance]);

    // Check new objects is come from previous objects.
    for (ROI_Object_Data object_new:objects_new) {
      /*
      // Check object_new is big enough.
      if (!object_new.big_enough) continue;
      */

      //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DETECT_OBJECTS_DBG) println("ROI_Data:detect_objects():"+"object_new["+objects_new.indexOf(object_new)+"]:"+"scr_start_x="+object_new.scr_start_x+",scr_start_y="+object_new.scr_start_y+",scr_end_x="+object_new.scr_end_x+",scr_end_y="+object_new.scr_end_y);

      //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"object_new.mi_diameter="+object_new.mi_diameter);

      int distance_min = MAX_INT;
      ROI_Object_Data object_last_distance_min = null;
      // Find nearest object of objects_last.
      for (ROI_Object_Data object_last:objects_last[instance]) {
        int distance =
          get_points_distance(
            object_new.mi_center_x,
            object_new.mi_center_y,
            object_last.mi_center_x,
            object_last.mi_center_y);

        //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"object_last.mi_diameter="+object_last.mi_diameter);
        //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"distance               ="+distance);

        // Check distance of object_new and object_last is near.
        if (distance > ((object_new.mi_diameter + ROI_OBJECT_DETECT_POINTS_DISTANCE_MAX * 2) / 2)
            ||
            distance > ((object_last.mi_diameter + ROI_OBJECT_DETECT_POINTS_DISTANCE_MAX * 2) / 2)) {
          continue;
        }
        //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DETECT_OBJECTS_DBG) println("ROI_Data:detect_objects():"+"object_last["+objects_last[instance].indexOf(object_last)+"]:"+"overlapped");

        // Check distance of object_new and object_last is min.
        if (distance >= distance_min) {
          continue;
        }
        distance_min = distance;
        object_last_distance_min = object_last;
      } // End of for (ROI_Object_Data object_last:objects_last[instance])

      if (distance_min != MAX_INT) {
        //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"object_last_distance_min.mi_diameter="+object_last_distance_min.mi_diameter);
        //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"distance_min                        ="+distance_min);
        if (PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG) println("ROI_Data:detect_objects("+instance+")"+":object_new.appeared_time_start ="+object_new.appeared_time_start+":object_new="+object_new);

        if (object_last_distance_min.appeared_time_start < object_new.appeared_time_start) {
          object_new.appeared_time_start = object_last_distance_min.appeared_time_start;
        }

        // Check object_last_distance_min and object_new are big enough.
        // And, Check region index min of objects are same.
        if (object_last_distance_min.big_enough && object_new.big_enough) {
          for (int region_index_new:object_new.region_indexes) {
            for (int region_index_last:object_last_distance_min.region_indexes) {
              if (region_index_last != region_index_new) {
                continue;
              }
              if (PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG) println("ROI_Data:detect_objects("+instance+")"+":object_last_distance_min.detected_time_start[region_index_last]="+object_last_distance_min.detected_time_start[region_index_last]+":object_last_distance_min="+object_last_distance_min);
              if (PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG) println("ROI_Data:detect_objects("+instance+")"+":object_new.detected_time_start[region_index_new] ="+object_new.detected_time_start[region_index_new]+":object_new="+object_new);

              if (object_last_distance_min.detected_time_total_start < object_new.detected_time_total_start) {
                object_new.detected_time_total_start = object_last_distance_min.detected_time_total_start;
              }
              if (object_last_distance_min.detected_time_start[region_index_last] < object_new.detected_time_start[region_index_new]) {
                object_new.detected_time_start[region_index_new] = object_last_distance_min.detected_time_start[region_index_last];
              }
              if (PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG) println("ROI_Data:detect_objects("+instance+")"+":object_new.detected_time_last[region_index_new]  ="+object_new.detected_time_last[region_index_new]+":object_new="+object_new);
              break;
            } // End of for (int region_index_last:object_last_distance_min.region_indexes)
          } // End of for (int region_index_new:object_new.region_indexes)

          object_last_distance_min.reused = true;
        } // End of if (object_last_distance_min.big_enough && object_new.big_enough)
      } // End of if (distance_min != MAX_INT)
    } // End of for (ROI_Object_Data object_new:objects_new)
    //Dbg_Time_logs_handle.add("ROI_Data:detect_objects("+instance+"):End of for loop 1");

    //if (PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG) println("ROI_Data:detect_objects("+instance+"):"+"after objects_last[instance].size()="+objects_last[instance].size());

    if (PRINT_ROI_OBJECTS_GHOST_ISSUE_DBG) println("ROI_Data:detect_objects("+instance+"):"+"after objects_last[instance].size()="+objects_last[instance].size());
    //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"after objects_last[instance].size()="+objects_last[instance].size());

    // Check disappeared object on previous objects
    for (ROI_Object_Data object_last:objects_last[instance]) {
      // Check object_last is reused.
      if (object_last.reused) {
        continue;
      }

      // Check object_last is big enough.
      if (!object_last.big_enough) {
        continue;
      }

      /**/
      boolean set_disappeared = false;
      boolean add_object_last = false;
      int detected_time_total_last_max = MIN_INT;
      int detected_time_total_start_min = MAX_INT;
      //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"object_last old detected_time_total="+get_int_diff(object_last.detected_time_total_last, object_last.detected_time_total_start));
      //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"object_last.disappeared="+object_last.disappeared);
      for (int region_index = 0; region_index < object_last.regions_count; region_index ++) {
        int time_duration =
          get_int_diff(
            object_last.detected_time_last[region_index],
            object_last.detected_time_start[region_index]);
        //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DETECT_OBJECTS_DBG) println("ROI_Data:detect_objects("+instance+"):"+"time_duration="+time_duration);
        if (PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG) println("ROI_Data:detect_objects("+instance+"):"+"object_last region_index="+region_index+",time_duration="+time_duration);
        //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"object_last region_index="+region_index+",old time_duration="+time_duration);
        /**/
        if (object_last.disappeared == false) {
          if (region_index == 0 && time_duration >= ROI_OBJECT_DETECT_TIME_MIN * 2) {
            object_last.detected_time_last[region_index] =
              time_stamp_new[instance];
            object_last.detected_time_start[region_index] =
              time_stamp_new[instance]
              -
              ROI_OBJECT_DETECT_TIME_MIN * 2
              -
              ROI_OBJECT_DETECT_KEEP_TIME
              +
              1;
            detected_time_total_last_max =
              max(
                detected_time_total_last_max,
                object_last.detected_time_last[region_index]);
            detected_time_total_start_min =
              min(
                detected_time_total_start_min,
                object_last.detected_time_start[region_index]);
            //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"object_last region_index="+region_index+",new time_duration="+get_int_diff(object_last.detected_time_last[region_index], object_last.detected_time_start[region_index]));
            set_disappeared = true;
            add_object_last = true;
          }
          else if (time_duration >= ROI_OBJECT_DETECT_TIME_MIN) {
            object_last.detected_time_last[region_index] =
              time_stamp_new[instance];
            object_last.detected_time_start[region_index] =
              time_stamp_new[instance]
              -
              ROI_OBJECT_DETECT_TIME_MIN
              -
              ROI_OBJECT_DETECT_KEEP_TIME
              +
              1;
            detected_time_total_last_max =
              max(
                detected_time_total_last_max,
                object_last.detected_time_last[region_index]);
            detected_time_total_start_min =
              min(
                detected_time_total_start_min,
                object_last.detected_time_start[region_index]);
            //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"object_last region_index="+region_index+",new time_duration="+get_int_diff(object_last.detected_time_last[region_index], object_last.detected_time_start[region_index]));
            set_disappeared = true;
            add_object_last = true;
          }
        }
        else {
          if (time_duration > 0) {
            time_duration -=
              get_int_diff(
                  time_stamp_new[instance],
                  object_last.detected_time_last[region_index]);
            //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"object_last region_index="+region_index+",disappeared time_duration="+time_duration);
            object_last.detected_time_last[region_index] =
              time_stamp_new[instance];
            object_last.detected_time_start[region_index] =
              time_stamp_new[instance] - time_duration;
            detected_time_total_last_max =
              max(
                detected_time_total_last_max,
                object_last.detected_time_last[region_index]);
            detected_time_total_start_min =
              min(
                detected_time_total_start_min,
                object_last.detected_time_start[region_index]);
            //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"object_last region_index="+region_index+",new time_duration="+get_int_diff(object_last.detected_time_last[region_index], object_last.detected_time_start[region_index]));
            add_object_last = true;
          }
        }
      } // End of for (int region_index:object_last.region_indexes)
      if (add_object_last) {
        if (set_disappeared) {
          object_last.disappeared = true;
        }
        object_last.detected_time_total_last = detected_time_total_last_max;
        object_last.detected_time_total_start = detected_time_total_start_min;
        //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"object_last new detected_time_total="+get_int_diff(object_last.detected_time_total_last, object_last.detected_time_total_start));
        objects_new.add(object_last);
      }
    } // End of for (ROI_Object_Data object_last:objects_last[instance])

    //SYSTEM_logger.info("ROI_Data:detect_objects("+instance+"):"+"end objects_new.size()="+objects_new.size());
    // Save objects_new to objects_last.
    objects_last[instance] = objects_new;
    //Dbg_Time_logs_handle.add("ROI_Data:detect_objects("+instance+"):End of for loop 2");

    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DETECT_OBJECTS_DBG) println("ROI_Data:detect_objects("+instance+"):Exit");
  }

  /*
  void print_points(int instance) {
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_PRINT_POINTS_DBG) println("ROI_Data:print_points("+instance+"):");
    int i = 0;
    println("ROI_Data:print_points("+instance+"):"+"points length="+points_new[instance].size());
    for (ROI_Point_Data point:points_new[instance]) {
      println("ROI_Data:print_points("+instance+"):"+"point["+i+++"]:"+"region="+point.region+",mi_x="+point.mi_x+",mi_y="+point.mi_y+",scr_x="+point.scr_x+",scr_y="+point.scr_y);
    }
  }
  */

  void draw_objects(int instance) {
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DRAW_OBJECTS_DBG) println("ROI_Data:draw_objects("+instance+"):Enter");

    // Check have objects to draw.
    if (objects_last[instance].size() == 0) {
      return;
    }

    boolean no_marker = false;

    // Check no mark region has too big object.
    for (ROI_Object_Data object:objects_last[instance]) {
      //SYSTEM_logger.info("ROI_Data:draw_objects("+instance+")"+":object.big_enough="+object.big_enough+":object.mi_diameter="+object.mi_diameter);
      // Check object is big enough.
      if (!object.big_enough) continue;
      // Check object is big enough for no mark.
      if (object.mi_diameter < ROI_OBJECT_NO_MARK_BIG_DIAMETER_MIN) continue;

      boolean no_mark_big = false;
      int region_index = -1;
      for (int i = 0; i < object.region_indexes.size(); i ++) {
        region_index = object.region_indexes.get(i);
        //SYSTEM_logger.info("ROI_Data:draw_objects("+instance+")"+":"+i+":region_index="+region_index+":time_duration="+get_int_diff(object.detected_time_last[region_index], object.detected_time_start[region_index]));
        if (Regions_handle.get_region_no_mark_big(instance, region_index))
        {
          no_mark_big = true;
          break;
        }
      }

      if (no_mark_big) {
        // Check object is detected during enough time.
        int time_duration = get_int_diff(object.detected_time_last[region_index], object.detected_time_start[region_index]);
        //SYSTEM_logger.info("ROI_Data:draw_objects("+instance+")"+":time_duration="+time_duration);
        if (time_duration < ROI_OBJECT_DETECT_TIME_MIN) {
          if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DRAW_OBJECTS_DBG) println("ROI_Data:draw_objects("+instance+"):"+"time_duration="+time_duration);
          continue;
        }

        if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DRAW_OBJECTS_DBG) println("ROI_Data:draw_objects("+instance+"):"+"object.mi_diameter="+object.mi_diameter);
        // No mark for all object when no mark region has big object.
        no_marker = true;
        break;
      }
    }
    //SYSTEM_logger.info("ROI_Data:draw_objects("+instance+")"+":no_marker="+no_marker);

    ROI_Detected_Objects detected_objects_new = new ROI_Detected_Objects(no_marker);
    Regions_handle.reset_regions_has_object(instance);
    // Start from object that detected on low priority region.
    for (int priority = Regions_handle.regions_priority_max[instance]; priority >= 0; priority --) {
      for (int i = 0; i < objects_last[instance].size(); i ++) {
        ROI_Object_Data object = objects_last[instance].get(i);
        if (Regions_handle.get_region_priority(instance, object.region_index_min) != priority) {
          continue;
        }
        // Check object is big enough.
        if (!object.big_enough) continue;

        //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DRAW_OBJECTS_DBG) println("ROI_Data:draw_objects("+instance+"):"+"x="+object.scr_start_x+",y="+object.scr_start_y+",w="+object.scr_width+",h="+object.scr_height);
        //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DRAW_OBJECTS_DBG) println("ROI_Data:draw_objects("+instance+"):"+"x_c="+object.scr_center_x+",y_c="+object.scr_center_y+",d="+object.scr_diameter);
        //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DRAW_OBJECTS_DBG) println("ROI_Data:draw_objects("+instance+"):"+"detected_time_start[0]="+object.detected_time_start[0]+",detected_time_last[0]="+object.detected_time_last[0]);

        // Get first detected time is long enough for each region.
        int time_duration_detected = -1;
        int region_index_detected = -1;
        boolean region_index_detected_found = false;
        for (int i_1 = 0; i_1 < object.region_indexes.size(); i_1 ++) {
          region_index_detected = object.region_indexes.get(i_1);
          time_duration_detected =
            get_int_diff(
              object.detected_time_last[region_index_detected],
              object.detected_time_start[region_index_detected]);
          if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DRAW_OBJECTS_DBG || PRINT_ROI_OBJECTS_GHOST_ISSUE_DBG) println("ROI_Data:draw_objects("+instance+")"+":"+i+":time_duration_detected="+time_duration_detected);

          // Check object is detected during enough time.
          if (time_duration_detected < ROI_OBJECT_DETECT_TIME_MIN) {
            if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DRAW_OBJECTS_DBG || PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG) println("ROI_Data:draw_objects("+instance+")"+":"+i+":time too short time_duration_detected="+time_duration_detected);
            continue;
          }
          if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG) println("ROI_Data:draw_objects("+instance+")"+":"+i+":time long enough time_duration_detected="+time_duration_detected);

          region_index_detected_found = true;
          break;
        }

        if (region_index_detected_found != true) {
          continue;
        }

        int time_duration_detected_total = get_int_diff(object.detected_time_total_last, object.detected_time_total_start);

        // Check detected region is first region.
        if (region_index_detected == 0) {
          //int time_duration_appeared = get_int_diff(object.appeared_time_last, object.appeared_time_start);
          if (time_duration_detected_total == time_duration_detected) {
            if (time_duration_detected < ROI_OBJECT_DETECT_TIME_MIN * 2) {
              continue;
            }
            //SYSTEM_logger.info("time_duration_appeared="+time_duration_appeared);
            //SYSTEM_logger.info("time_duration_detected_total="+time_duration_detected_total);
            //SYSTEM_logger.info("time_duration_detected="+time_duration_detected);
          }
          else {
            //SYSTEM_logger.info("time_duration_appeared="+time_duration_appeared);
            //SYSTEM_logger.info("time_duration_detected_total="+time_duration_detected_total);
            //SYSTEM_logger.info("time_duration_detected="+time_duration_detected);
          }
        }

        detected_objects_new.add(new ROI_Detected_Object_Data(object.mi_center_x, object.mi_center_y, object.mi_diameter));
        for (int region_index:object.region_indexes) {
          if (region_index >= region_index_detected) {
            Regions_handle.set_region_has_object(instance, region_index);
            //println("ROI_Data:draw_objects("+instance+"):"+"set_region_has_object("+region_index+");");
          }
        }
        if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DRAW_OBJECTS_DBG || PRINT_ROI_OBJECTS_GHOST_ISSUE_DBG) println("ROI_Data:draw_objects("+instance+")"+":"+i+":mi c_x="+object.mi_center_x+",c_x="+object.mi_center_y+",dia="+object.mi_diameter);

        if (no_marker) {
          // No marker for all object when no mark region has big object.
          continue;
        }

        int weight;

        weight = 1 * time_duration_detected / ROI_OBJECT_DETECT_TIME_MIN;
        weight = min(weight, Regions_handle.get_marker_stroke_weight(instance, region_index_detected));
        fill(Regions_handle.get_marker_fill_color(instance, region_index_detected));
        // Sets the color and weight used to draw lines and borders around shapes.
        stroke(Regions_handle.get_marker_stroke_color(instance, region_index_detected));
        strokeWeight(weight);
        /*
        rect( object.scr_start_x - ROI_OBJECT_MARKER_MARGIN,
              object.scr_start_y - ROI_OBJECT_MARKER_MARGIN,
              object.scr_width + ROI_OBJECT_MARKER_MARGIN*2,
              object.scr_height + ROI_OBJECT_MARKER_MARGIN*2);
        */
        ellipse(object.scr_center_x,
                object.scr_center_y,
                object.scr_diameter + ROI_OBJECT_MARKER_MARGIN*2,
                object.scr_diameter + ROI_OBJECT_MARKER_MARGIN*2);
        /*
        //fill(0x00000000);
        fill(0x00FFFFFF);
        stroke(0);
        strokeWeight(1);
        ellipse(object.scr_center_x,
                object.scr_center_y,
                object.scr_diameter + ROI_OBJECT_MARKER_MARGIN*2,
                object.scr_diameter + ROI_OBJECT_MARKER_MARGIN*2);
        */
      } //  End of for (ROI_Object_Data object:objects_last[instance])
    } // End of for (int priority = Regions_handle.regions_priority_max[instance]; priority >= 0; priority --)

    //println("ROI_Data:draw_objects("+instance+"):detected_objects_last["+instance+"]="+detected_objects_last[instance]);
    if (detected_objects_new.are_same(detected_objects_last[instance])) {
      detected_objects_are_same[instance] = true;
    }
    else {
      detected_objects_are_same[instance] = false;
    }

    //println("ROI_Data:draw_objects("+instance+")"+":detected_objects_are_same["+instance+"]="+detected_objects_are_same[instance]);
    
    // Save detected_objects_new.
    detected_objects_last[instance] = detected_objects_new;

    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DRAW_OBJECTS_DBG) println("ROI_Data:draw_objects("+instance+"):has_objects_count["+instance+"]="+has_objects_count[instance]);
    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DRAW_OBJECTS_DBG) println("ROI_Data:draw_objects("+instance+"):Exit");
  }

  int copy_count = 0;
  int copy_time_sum = 0;
  void save_events(int instance) {
    // Save events feature will not run when PS Interface is FILE.
    if (PS_Interface[instance] == PS_Interface_FILE) return;

    if (!PS_Data_save_enabled) return;

    // Check events directory ready.
    if (!File_Operations_events_dir_ready) {
      if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_SAVE_EVENT_DBG) println("ROI_Data:save_events("+instance+"):events dir is not ready!");
      return;
    }

    if (
        (
          !detected_objects_last[instance].have_detected_objects
          ||
          detected_objects_last[instance].is_no_marker
        )
        &&
        !File_Operations_save_events_started[instance])
      return;

    // Check save events started.
    if (!File_Operations_save_events_started[instance]) {
      if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_SAVE_EVENT_DBG) println("ROI_Data:save_events("+instance+"):save events start!");
      SYSTEM_logger.info("ROI_Data:save_events("+instance+"):save events start!");  
      if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_SAVE_EVENT_DBG) println("ROI_Data:save_events("+instance+"):detected_objects_last["+instance+"].have_detected_objects="+detected_objects_last[instance].have_detected_objects);
      // Save events not started.
      File_Operations_save_events_event_date_time[instance] =
        new Date().getTime();
      File_Operations_save_events_start_date_time[instance] =
        File_Operations_save_events_event_date_time[instance]
        -
        PS_DATA_SAVE_EVENTS_DURATION_DEFAULT;
      File_Operations_save_events_end_date_time[instance] =
        File_Operations_save_events_event_date_time[instance]
        +
        PS_DATA_SAVE_EVENTS_DURATION_DEFAULT;
      if (OS_is_Windows)
      {
        File_Operations_save_events_dir_full_name[instance] =
          sketchPath()
          +"\\events\\"
          +nf(year(),4)+nf(month(),2)+nf(day(),2)
          +"\\"
          +nf(year(),4)+nf(month(),2)+nf(day(),2)
          +"_"
          +nf(hour(),2)+nf(minute(),2)+nf(second(),2)
          +"_"
          +nf(int(File_Operations_save_events_event_date_time[instance]%1000),3)
          +"_"
          +instance+"\\";
      }
      else
      {
        File_Operations_save_events_dir_full_name[instance] =
          sketchPath()
          +"/events/"
          +nf(year(),4)+nf(month(),2)+nf(day(),2)
          +"/"
          +nf(year(),4)+nf(month(),2)+nf(day(),2)
          +"_"
          +nf(hour(),2)+nf(minute(),2)+nf(second(),2)
          +"_"
          +nf(int(File_Operations_save_events_event_date_time[instance]%1000),3)
          +"_"
          +instance+"/";
      }

      File_Operations_save_events_write_events_done[instance] = false;
      File_Operations_save_events_done[instance] = false;
      File_Operations_save_events_started[instance] = true;
      return;
    }
    
    // Save events started.
    // Check it has objects to save events.
    if (detected_objects_last[instance].have_detected_objects) {
      // Advance end date time.
      // Get current date time.
      long date_time_curr = new Date().getTime();

      // Check advanced end date time will reached to limit.
      if (
            date_time_curr + PS_DATA_SAVE_EVENTS_DURATION_DEFAULT
            <=
            (
              File_Operations_save_events_event_date_time[instance]
              +
              PS_DATA_SAVE_EVENTS_DURATION_LIMIT
            )
          ) {
        File_Operations_save_events_end_date_time[instance] =
          date_time_curr + PS_DATA_SAVE_EVENTS_DURATION_DEFAULT;
      }
    }

    // Check save events done.
    if (!File_Operations_save_events_done[instance]) {
      return;
    }

    // Check detected object are same.
    if (detected_objects_last[instance].have_detected_objects
        &&
        detected_objects_are_same[instance]) {
      return;
    }

    // Save events done.
    // Stop save events.
    File_Operations_save_events_write_events_done[instance] = false;
    File_Operations_save_events_done[instance] = false;
    File_Operations_save_events_started[instance] = false;
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_SAVE_EVENT_DBG) println("ROI_Data:save_events("+instance+"):save events end!");
    SYSTEM_logger.info("ROI_Data:save_events("+instance+"):save events end!");  
  }

  void draw_object_info(int instance) {
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DRAW_OBJECT_INFO_DBG) println("ROI_Data:draw_object_info("+instance+"):Enter");

    if (!ROI_Data_draw_info_enabled[instance]) return;

    if (get_millis_diff(ROI_Data_draw_info_timer[instance])
        >=
        SYSTEM_UI_TIMEOUT * 1000)
    {
      ROI_Data_draw_info_enabled[instance] = false;
    }

    if (objects_last[instance].size() == 0) return;
    //if (objects_last[instance].size() <= ROI_Data_mouse_over_object_index[instance]) return;

    ROI_Object_Data object;
    int distance_min = MAX_INT, distance_min_index = MAX_INT;

    //println(instance+":x="+ROI_Data_draw_info_x[instance]+",y="+ROI_Data_draw_info_y[instance]);
    for (int i = 0; i < objects_last[instance].size(); i ++) {
      int distance;
      object = objects_last[instance].get(i);
      //println(instance+","+i+":c.x="+object.scr_center_x+",y="+object.scr_center_y+",d="+object.scr_diameter);
      distance =
        get_points_distance(
          ROI_Data_draw_info_x[instance],
          ROI_Data_draw_info_y[instance],
          object.scr_center_x,
          object.scr_center_y);
      if (distance <= (object.scr_diameter + ROI_OBJECT_MARKER_MARGIN * 2) / 2) {
        //println(instance+","+i+":distance="+distance);
        if (distance < distance_min) {
          distance_min = distance;
          distance_min_index = i;
        }
      }
    }
    if (distance_min_index == MAX_INT) return;
    //println(instance+":distance_min="+distance_min+":distance_min_index="+distance_min_index);

    //ROI_Data_draw_info_enabled[instance] = false;

    object = objects_last[instance].get(distance_min_index);
    /*
    ROI_Object_Data object;

    for (ROI_Object_Data o:objects_last[instance]) {
      if( ROI_Data_draw_info_x[instance] >= o.scr_start_x - ROI_OBJECT_MARKER_MARGIN
          &&
          ROI_Data_draw_info_x[instance] <= o.scr_end_x + ROI_OBJECT_MARKER_MARGIN
          && 
          ROI_Data_draw_info_y[instance] >= o.scr_start_y - ROI_OBJECT_MARKER_MARGIN
          &&
          ROI_Data_draw_info_y[instance] <= o.scr_end_y + ROI_OBJECT_MARKER_MARGIN
        ) {
        object = o;
        break;
      }
    }
    */
    /*
    object = objects_last[instance].get(ROI_Data_mouse_over_object_index[instance]);

    if( ROI_Data_draw_info_x[instance] < object.scr_start_x - ROI_OBJECT_MARKER_MARGIN
        ||
        ROI_Data_draw_info_x[instance] > object.scr_end_x + ROI_OBJECT_MARKER_MARGIN
        || 
        ROI_Data_draw_info_y[instance] < object.scr_start_y - ROI_OBJECT_MARKER_MARGIN
        ||
        ROI_Data_draw_info_y[instance] > object.scr_end_y + ROI_OBJECT_MARKER_MARGIN
      ) {
      return;
    }
    */

    ROI_Data_draw_info_x[instance] = object.scr_center_x;
    ROI_Data_draw_info_y[instance] = object.scr_center_y;

    ArrayList<String> strings = new ArrayList<String>();

    strings.add("Region:" + Regions_handle.get_region_name(instance, object.region_indexes.get(0)));
    strings.add("Appeared dur.:" + ((get_int_diff(object.appeared_time_last, object.appeared_time_start))/100/10.) + "s");
    strings.add("Detected dur.:" + ((get_int_diff(object.detected_time_last[object.region_index_min], object.detected_time_start[object.region_index_min]))/100/10.) + "s");
    strings.add("Distance:" + ((object.mi_distance/10)/1000.0) + "m");
    // Check need to rotate x,y,w,h.
    if (ROTATE_FACTOR[instance] == 315 || ROTATE_FACTOR[instance] == 135)
    {
      strings.add("Center X:" + ((object.mi_center_y/10)/1000.0) + "m");
      strings.add("Center Y:" + ((object.mi_center_x/10)/1000.0) + "m");
      strings.add("Width:" + ((object.mi_height/10)/1000.0) + "m");
      strings.add("Height:" + ((object.mi_width/10)/1000.0) + "m");
    }
    else
    {
      strings.add("Center X:" + ((object.mi_center_x/10)/1000.0) + "m");
      strings.add("Center Y:" + ((object.mi_center_y/10)/1000.0) + "m");
      strings.add("Width:" + ((object.mi_width/10)/1000.0) + "m");
      strings.add("Height:" + ((object.mi_height/10)/1000.0) + "m");
    }
    strings.add("Diameter:" + ((object.mi_diameter/10)/1000.0) + "m");
    strings.add("Num. of points:" + object.number_of_points);
    strings.add("Time-out:" + ((SYSTEM_UI_TIMEOUT * 1000 + 1000 - get_millis_diff(ROI_Data_draw_info_timer[instance]))/1000) + "s");

    // Get max string width
    textSize(FONT_HEIGHT);
    int witdh_max = 0;
    for (String string:strings)
    {
      witdh_max = max(witdh_max, int(textWidth(string)));    
    }

    int rect_w, rect_h;
    int rect_x, rect_y;
    int rect_tl = 5, rect_tr = 5, rect_br = 5, rect_bl = 5;
    rect_w = witdh_max + TEXT_MARGIN * 2;
    rect_h = FONT_HEIGHT * strings.size() + TEXT_MARGIN * 2;
    if (ROTATE_FACTOR[instance] == 315) {
      if (MIRROR_ENABLE[instance]) { // OK
        rect_x = object.scr_center_x;
        rect_y = object.scr_center_y;
        rect_tl = 0;
      }
      else { // OK
        rect_x = object.scr_center_x;
        rect_y = object.scr_center_y - rect_h - 1;
        rect_bl = 0;
      }
    }
    else if (ROTATE_FACTOR[instance] == 45) {
      if (MIRROR_ENABLE[instance]) { // OK
        rect_x = object.scr_center_x - rect_w - 1;
        rect_y = object.scr_center_y;
        rect_tr = 0;
      }
      else { // OK
        rect_x = object.scr_center_x;
        rect_y = object.scr_center_y;
        rect_tl = 0;
      }
    }
    else if (ROTATE_FACTOR[instance] == 135) {
      if (MIRROR_ENABLE[instance]) { // OK
        rect_x = object.scr_center_x - rect_w - 1;
        rect_y = object.scr_center_y - rect_h - 1;
        rect_br = 0;
      }
      else { // OK
        rect_x = object.scr_center_x - rect_w - 1;
        rect_y = object.scr_center_y;
        rect_tr = 0;
      }
    }
    else /*if (ROTATE_FACTOR[instance] == 225)*/ {
      if (MIRROR_ENABLE[instance]) { // OK
        rect_x = object.scr_center_x;
        rect_y = object.scr_center_y - rect_h - 1;
        rect_bl = 0;
      }
      else { // OK
        rect_x = object.scr_center_x - rect_w - 1;
        rect_y = object.scr_center_y - rect_h - 1;
        rect_br = 0;
      }
    }

    if (rect_x < 0 && rect_y < 0) {
      if (rect_br == 0) {
        rect_x = object.scr_center_x;
        rect_y = object.scr_center_y;
        if (rect_x < 0)
          rect_x = 0;
        if (rect_y < 0)
          rect_y = 0;
        rect_tl = 0;
        rect_br = 5;
      }
      else {
        rect_x = rect_y = 0;
      }
    }
    else if (rect_x < 0) {
      if (rect_tr == 0) {
        rect_x = object.scr_center_x;
        if (rect_x < 0)
          rect_x = 0;
        rect_tl = 0;
        rect_tr = 5;
      }
      else if (rect_br == 0) {
        rect_x = object.scr_center_x;
        if (rect_x < 0)
          rect_x = 0;
        rect_bl = 0;
        rect_br = 5;
      }
      else {
        rect_x = 0;
      }
    }
    else if (rect_y < 0) {
      if (rect_br == 0) {
        rect_y = object.scr_center_y;
        if (rect_y < 0)
          rect_y = 0;
        rect_tr = 0;
        rect_br = 5;
      }
      else if (rect_bl == 0) {
        rect_y = object.scr_center_y;
        if (rect_y < 0)
          rect_y = 0;
        rect_tl = 0;
        rect_bl = 5;
      }
      else {
        rect_y = 0;
      }
    }

    if (rect_x + rect_w > SCREEN_width && rect_y + rect_h > SCREEN_height) {
      if (rect_tl == 0) {
        rect_x = object.scr_center_x - rect_w - 1;
        rect_y = object.scr_center_y - rect_h - 1;
        if (rect_x + rect_w > SCREEN_width)
          rect_x = SCREEN_width - rect_w;
        if (rect_y + rect_h > SCREEN_height)
          rect_y = SCREEN_height - rect_h;
        rect_br = 0;
        rect_tl = 5;
      }
      else {
        rect_x = SCREEN_width - rect_w;
        rect_y = SCREEN_height - rect_h;
      }
    }
    else if (rect_x + rect_w > SCREEN_width ) {
      if (rect_bl == 0) {
        rect_x = object.scr_center_x - rect_w - 1;
        if (rect_x + rect_w > SCREEN_width)
          rect_x = SCREEN_width - rect_w;
        rect_br = 0;
        rect_bl = 5;
      }
      else if (rect_tl == 0) {
        rect_x = object.scr_center_x - rect_w - 1;
        if (rect_x + rect_w > SCREEN_width)
          rect_x = SCREEN_width - rect_w;
        rect_tr = 0;
        rect_tl = 5;
      }
      else {
        rect_x = SCREEN_width - rect_w;
      }
    }
    else if (rect_y + rect_h > SCREEN_height) {
      if (rect_tl == 0) {
        rect_y = object.scr_center_y - rect_h - 1;
        if (rect_y + rect_h > SCREEN_height)
          rect_y = SCREEN_height - rect_h;
        rect_bl = 0;
        rect_tl = 5;
      }
      else if (rect_tr == 0) {
        rect_y = object.scr_center_y - rect_h - 1;
        if (rect_y + rect_h > SCREEN_height)
          rect_y = SCREEN_height - rect_h;
        rect_br = 0;
        rect_tr = 5;
      }
      else {
        rect_y = SCREEN_height - rect_h;
      }
    }

    // Draw rect
    fill(C_PS_DATA_RECT_FILL);
    // Sets the color and weight used to draw lines and borders around shapes.
    stroke(C_PS_DATA_RECT_STROKE);
    strokeWeight(W_PS_DATA_RECT_STROKE);
    rect(rect_x, rect_y, rect_w, rect_h, rect_tl, rect_tr, rect_br, rect_bl);

    // Sets the color used to draw lines and borders around shapes.
    fill(C_PS_DATA_RECT_TEXT);
    stroke(C_PS_DATA_RECT_TEXT);
    textAlign(LEFT, BASELINE);
    final int str_x = rect_x + TEXT_MARGIN;
    final int str_y = rect_y + TEXT_MARGIN - 1;
    int cnt = 0;
    for( String string:strings)
    {
      text(string, str_x, str_y + FONT_HEIGHT * (1 + cnt++));
    }

    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_DRAW_OBJECT_INFO_DBG) println("ROI_Data:draw_object_info("+instance+"):Enter");
  }

  boolean check_scr_xy_over_objects(int instance, int x, int y, int margin) {
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_CHECK_SCR_XY_OVER_OBJECTS_DBG) println("ROI_Data:check_scr_xy_over_objects():Enter");

    boolean ret = false;

    for (ROI_Object_Data object:objects_last[instance]) {
      if (get_points_distance(x, y, object.scr_center_x, object.scr_center_y)
          <=
          (object.scr_diameter + margin * 2) / 2) {
        ret = true;
        break;
      }
    }

    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_CHECK_SCR_XY_OVER_OBJECTS_DBG) println("ROI_Data:check_scr_xy_over_objects():ret="+ret);

    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_CHECK_SCR_XY_OVER_OBJECTS_DBG) println("ROI_Data:check_scr_xy_over_objects():Exit");

    return ret;
  }

  private void get_objects(ArrayList<ROI_Object_Data> objects, ArrayList<ROI_Point_Data> points_list, int time_stamp, int regions_count, float angle_step) {
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECTS_DBG) println("ROI_Data:get_objects():Enter");
    if (points_list.size() == 0) {
      if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECTS_DBG) println("ROI_Data:get_objects():"+"points_list size is 0. Nothing to do.");
      return;
    }

    ArrayList<ROI_Point_Data> points_group = new ArrayList<ROI_Point_Data>();
    // Grab near points sequential order.
    do {
      //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECTS_DBG) println("ROI_Data:get_objects():"+"points_list size="+points_list.size());
      points_group.add(points_list.get(0));
      points_list.remove(0);

      ROI_Point_Data points_group_point;
      ROI_Point_Data points_list_point;
      int distance;

      // Grab near points with points_group
      //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECTS_DBG) println("ROI_Data:get_objects():"+"points_list size="+points_list.size());
      //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECTS_DBG) println("ROI_Data:get_objects():"+"points_group size="+points_group.size());
      for (int i = 0; i < points_group.size(); i ++) {
        points_group_point = points_group.get(i);
        //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECTS_DBG) println("ROI_Data:get_objects():"+"points_group_point["+0+"]:"+"region="+points_group_point.region+",mi_x="+points_group_point.mi_x+",mi_y="+points_group_point.mi_y+",scr_x="+points_group_point.scr_x+",scr_y="+points_group_point.scr_y);
        for (int j = 0; j < points_list.size();) {
          points_list_point = points_list.get(j);
          //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECTS_DBG) println("ROI_Data:get_objects():"+"points_list_point["+i+"]:"+"region="+points_list_point.region+",mi_x="+points_list_point.mi_x+",mi_y="+points_list_point.mi_y+",scr_x="+points_list_point.scr_x+",scr_y="+points_list_point.scr_y);
          distance = get_points_distance(points_group_point.mi_x, points_group_point.mi_y, points_list_point.mi_x, points_list_point.mi_y);
          //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECTS_DBG) println("ROI_Data:detect_objects()"+":i="+i+":distance="+distance);
          if (distance <= ROI_OBJECT_DETECT_POINTS_DISTANCE_MAX) {
            points_group.add(points_list_point);
            points_list.remove(j);
          }
          else {
            j ++;
          }
        } // End of for (int j = 0; j < points_list.size();)
        //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECTS_DBG) println("ROI_Data:get_objects()"+":i="+i+":points_group size="+points_group.size());
      } // End of for (int i = 0; i < points_group.size(); i ++)
      //Dbg_Time_logs_handle.add("ROI_Data:get_objects():points_group.size()="+points_group.size());
      //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECTS_DBG) println("ROI_Data:get_objects():"+"points_group size="+points_group.size());
      add_object(objects, points_group, time_stamp, regions_count, angle_step);
      //Dbg_Time_logs_handle.add("ROI_Data:get_objects():objects.size()="+objects.size());
      points_group.clear();
      //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECTS_DBG) println("ROI_Data:get_objects():"+"points_list size="+points_list.size());
    } while (points_list.size() != 0);
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECTS_DBG) println("ROI_Data:get_objects():Exit");
  }

  private void add_object(ArrayList<ROI_Object_Data> objects, ArrayList<ROI_Point_Data> points_group, int time_stamp, int regions_count, float angle_step) {
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECT_DBG) println("ROI_Data:add_object():Enter");

    ArrayList<Integer> new_region_indexes = new ArrayList<Integer>();
    int region_index_min;
    int mi_x_min, mi_y_min, mi_x_max, mi_y_max;
    int scr_x_min, scr_y_min, scr_x_max, scr_y_max;

    region_index_min = MAX_INT;
    mi_x_min = mi_y_min = scr_x_min = scr_y_min = MAX_INT;
    mi_x_max = mi_y_max = scr_x_max = scr_y_max = MIN_INT;

    //if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECT_DBG) println("ROI_Data:add_object():"+"points_group size="+points_group.size());
    for (ROI_Point_Data point:points_group) {
      int region_index = point.region_indexes.get(0);
      if (region_index < region_index_min) {
        region_index_min = region_index;
        new_region_indexes.add(0, region_index_min); // Add first min region index.
      }
      else {
        if (!new_region_indexes.contains(region_index)) {
          new_region_indexes.add(region_index);
        }
      }
      for (int i = 1; i < point.region_indexes.size(); i ++) {
        region_index = point.region_indexes.get(i);
        if (new_region_indexes.contains(region_index)) continue;
        new_region_indexes.add(region_index);
      }

      mi_x_min = min(mi_x_min, point.mi_x);
      mi_y_min = min(mi_y_min, point.mi_y);
      mi_x_max = max(mi_x_max, point.mi_x);
      mi_y_max = max(mi_y_max, point.mi_y);
      scr_x_min = min(scr_x_min, point.scr_x);
      scr_y_min = min(scr_y_min, point.scr_y);
      scr_x_max = max(scr_x_max, point.scr_x);
      scr_y_max = max(scr_y_max, point.scr_y);
    } // End of for (ROI_Point_Data point:points_group)

    if (mi_x_min == mi_x_max && mi_y_min == mi_y_max) {
      int rot_x, rot_y;
      rot_x = get_point_rotate_x(mi_x_min, mi_y_min, angle_step);
      rot_y = get_point_rotate_y(mi_x_min, mi_y_min, angle_step);
      mi_x_min = min(mi_x_min, rot_x);
      mi_y_min = min(mi_y_min, rot_y);
      mi_x_max = max(mi_x_max, rot_x);
      mi_y_max = max(mi_y_max, rot_y);
    }

    objects.add(
      new ROI_Object_Data(
        time_stamp,
        regions_count,
        new_region_indexes,
        mi_x_min, mi_y_min,
        mi_x_max, mi_y_max,
        scr_x_min, scr_y_min,
        scr_x_max, scr_y_max,
        points_group.size()));
    if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECT_DBG) println("ROI_Data:add_object():Exit");
  }

}

class ROI_Point_Data {
  public ArrayList<Integer> region_indexes;
  public int mi_x, mi_y;
  public int scr_x, scr_y;
  
  ROI_Point_Data(ArrayList<Integer> region_indexes, int mi_x, int mi_y, int scr_x, int scr_y) {
    this.region_indexes = region_indexes;
    this.mi_x = mi_x;
    this.mi_y = mi_y;
    this.scr_x = scr_x;
    this.scr_y = scr_y;
  }
}

//final static boolean PRINT_ROI_OBJECT_DATA_ALL_DBG = true; 
final static boolean PRINT_ROI_OBJECT_DATA_ALL_DBG = false;
final static boolean PRINT_ROI_OBJECT_DATA_ALL_ERR = true; 
//final static boolean PRINT_ROI_OBJECT_DATA_ALL_ERR = false;

//final static boolean PRINT_ROI_OBJECT_DATA_CONSTRUCTOR_DBG = true; 
final static boolean PRINT_ROI_OBJECT_DATA_CONSTRUCTOR_DBG = false;
//final static boolean PRINT_ROI_OBJECT_DATA_CONSTRUCTOR_ERR = true; 
final static boolean PRINT_ROI_OBJECT_DATA_CONSTRUCTOR_ERR = false;

class ROI_Object_Data {
  public int regions_count;
  public ArrayList<Integer> region_indexes;
  public int region_index_min;
  public int mi_start_x, mi_start_y;
  public int mi_end_x, mi_end_y;
  public int mi_width, mi_height;
  public int mi_center_x, mi_center_y;
  public int mi_diameter;
  public int mi_distance;
  public int scr_start_x, scr_start_y;
  public int scr_end_x, scr_end_y;
  public int scr_width, scr_height;
  public int scr_center_x, scr_center_y;
  public int scr_diameter;
  public int appeared_time_start;
  public int appeared_time_last;
  public int detected_time_total_start;
  public int detected_time_total_last;
  public int[] detected_time_start;
  public int[] detected_time_last;
  public int number_of_points;
  public boolean big_enough = false;
  public boolean reused = false;
  public ROI_Object_Data reused_object = null;
  public boolean disappeared = false;
  
  ROI_Object_Data(int time_stamp, int regions_count, ArrayList<Integer> region_indexes, int mi_start_x, int mi_start_y, int mi_end_x, int mi_end_y, int scr_start_x, int scr_start_y, int scr_end_x, int scr_end_y, int number_of_points) {
    if (PRINT_ROI_OBJECT_DATA_ALL_DBG || PRINT_ROI_OBJECT_DATA_CONSTRUCTOR_DBG) println("ROI_Object_Data:constructor():"+"region_indexes.size()="+region_indexes.size());
    if (PRINT_ROI_OBJECT_DATA_ALL_DBG || PRINT_ROI_OBJECT_DATA_CONSTRUCTOR_DBG) println("ROI_Object_Data:constructor():"+"mi x="+mi_start_x+",y="+mi_start_y+",x="+mi_end_x+",y="+mi_end_y);
    if (PRINT_ROI_OBJECT_DATA_ALL_DBG || PRINT_ROI_OBJECT_DATA_CONSTRUCTOR_DBG) println("ROI_Object_Data:constructor():"+"scr x="+scr_start_x+",y="+scr_start_y+",x="+scr_end_x+",y="+scr_end_y);
    this.appeared_time_start =
    this.appeared_time_last = 
    this.detected_time_total_start =
    this.detected_time_total_last = time_stamp;
    this.detected_time_start = new int[regions_count];
    this.detected_time_last = new int[regions_count];
    //for (int region_index:region_indexes)
    //{
    //  this.detected_time_start[region_index] =
    //  this.detected_time_last[region_index] = time_stamp;
    //}
    for (int region_index = 0; region_index < regions_count; region_index ++)
    {
      this.detected_time_start[region_index] =
      this.detected_time_last[region_index] = time_stamp;
    }
    this.regions_count = regions_count;
    this.region_indexes = region_indexes;
    this.region_index_min = region_indexes.get(0);
    this.mi_start_x = mi_start_x;
    this.mi_start_y = mi_start_y;
    this.mi_end_x = mi_end_x;
    this.mi_end_y = mi_end_y;
    this.mi_width = mi_end_x - mi_start_x;
    this.mi_height = mi_end_y - mi_start_y;
    this.mi_center_x = mi_start_x + this.mi_width / 2;
    this.mi_center_y = mi_start_y + this.mi_height / 2;
    this.mi_diameter = get_points_distance(mi_start_x, mi_start_y, mi_end_x, mi_end_y);
    this.mi_distance = get_points_distance(0, 0, mi_center_x, mi_center_y);
    this.scr_start_x = scr_start_x;
    this.scr_start_y = scr_start_y;
    this.scr_end_x = scr_end_x;
    this.scr_end_y = scr_end_y;
    if (scr_start_x == scr_end_x) {
      this.scr_width = 1;
      this.scr_center_x = scr_start_x;
    }
    else {
      this.scr_width = scr_end_x - scr_start_x;
      this.scr_center_x = scr_start_x + this.scr_width / 2;
    }
    if (scr_start_y == scr_end_y) {
      this.scr_height = 1;
      this.scr_center_y = scr_start_y;
    }
    else {
      this.scr_height = scr_end_y - scr_start_y;
      this.scr_center_y = scr_start_y + this.scr_height / 2;
    }
    if (scr_start_x == scr_end_x && scr_start_y == scr_end_y) {
      this.scr_diameter = 1;
    }
    else {
      this.scr_diameter = get_points_distance(scr_start_x, scr_start_y, scr_end_x, scr_end_y);
    }
    this.number_of_points = number_of_points;
    // Check object diameter is big enough.
    if (this.mi_diameter >= ROI_OBJECT_DETECT_DIAMETER_MIN) {
      if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECT_DBG || PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG) println("ROI_Object_Data:ROI_Object_Data():"+"object is big enough this.mi_diameter="+this.mi_diameter);
      this.big_enough = true;
    }
    else {
      if (PRINT_ROI_DATA_ALL_DBG || PRINT_ROI_DATA_ADD_OBJECT_DBG || PRINT_ROI_OBJECTS_NODETECT_ISSUE_DBG) println("ROI_Object_Data:ROI_Object_Data():"+"object is too small. this.mi_diameter="+this.mi_diameter);
      //this.big_enough = false;
    }
    //this.reused = false;
    //this.disappeared = false;
  }

}

//final static boolean PRINT_ROI_DETECTED_OBJECTS_ALL_DBG = true;
final static boolean PRINT_ROI_DETECTED_OBJECTS_ALL_DBG = false;
final static boolean PRINT_ROI_DETECTED_OBJECTS_ALL_ERR = true;
//final static boolean PRINT_ROI_DETECTED_OBJECTS_ALL_ERR = false;

//final static boolean PRINT_ROI_DETECTED_OBJECTS_CONSTRUCTOR_DBG = true;
final static boolean PRINT_ROI_DETECTED_OBJECTS_CONSTRUCTOR_DBG = false;
//final static boolean PRINT_ROI_DETECTED_OBJECTS_CONSTRUCTOR_ERR = true;
final static boolean PRINT_ROI_DETECTED_OBJECTS_CONSTRUCTOR_ERR = false;

//final static boolean PRINT_ROI_DETECTED_OBJECTS_ARE_SAME_DBG = true;
final static boolean PRINT_ROI_DETECTED_OBJECTS_ARE_SAME_DBG = false;
//final static boolean PRINT_ROI_DETECTED_OBJECTS_ARE_SAME_ERR = true;
final static boolean PRINT_ROI_DETECTED_OBJECTS_ARE_SAME_ERR = false;

class ROI_Detected_Object_Data {
  public int mi_center_x, mi_center_y;
  public int mi_diameter;
  
  ROI_Detected_Object_Data(int mi_center_x, int mi_center_y, int mi_diameter) {
    if (PRINT_ROI_DETECTED_OBJECTS_ALL_DBG || PRINT_ROI_DETECTED_OBJECTS_CONSTRUCTOR_DBG) println("ROI_Detected_Object_Data:ROI_Detected_Object_Data()"+":Enter");
    this.mi_center_x = mi_center_x;
    this.mi_center_y = mi_center_y;
    this.mi_diameter = mi_diameter;
  }
}

class ROI_Detected_Objects {
  public ArrayList<ROI_Detected_Object_Data> objects_data = new ArrayList<ROI_Detected_Object_Data>();
  public boolean have_detected_objects;
  public int objects_count;
  public boolean is_no_marker;
  
  ROI_Detected_Objects() {
    if (PRINT_ROI_DETECTED_OBJECTS_ALL_DBG || PRINT_ROI_DETECTED_OBJECTS_CONSTRUCTOR_DBG) println("ROI_Detected_Objects:ROI_Detected_Objects()"+":Enter");
    have_detected_objects = false;
    is_no_marker = false;
    objects_count = 0;
  }

  ROI_Detected_Objects(boolean no_marker) {
    if (PRINT_ROI_DETECTED_OBJECTS_ALL_DBG || PRINT_ROI_DETECTED_OBJECTS_CONSTRUCTOR_DBG) println("ROI_Detected_Objects:ROI_Detected_Objects()"+":no_marker="+no_marker+":Enter");
    have_detected_objects = false;
    is_no_marker = no_marker;
    objects_count = 0;
  }

  void add(ROI_Detected_Object_Data object_data) {
    objects_data.add(object_data);
    have_detected_objects = true;
    objects_count ++;
  }

  void clear() {
    objects_data.clear();
    have_detected_objects = false;
    objects_count = 0;
  }

  boolean are_same(ROI_Detected_Objects other_objects_data) {
    //if (PRINT_ROI_DETECTED_OBJECTS_ALL_DBG || PRINT_ROI_DETECTED_OBJECTS_ARE_SAME_DBG) println("ROI_Detected_Objects:are_same()"+":Enter");
    // Check objects counts.
    if (this.objects_count != other_objects_data.objects_count) {
      if (PRINT_ROI_DETECTED_OBJECTS_ALL_DBG || PRINT_ROI_DETECTED_OBJECTS_ARE_SAME_DBG) println("ROI_Detected_Objects:are_same():objects count diff="+this.objects_count+","+ other_objects_data.objects_count);
      return false;
    }
    for (int i = 0; i < this.objects_data.size(); i ++) {
      ROI_Detected_Object_Data this_object_data =
        this.objects_data.get(i);
      ROI_Detected_Object_Data other_object_data =
        other_objects_data.objects_data.get(i);
      int object_diff;

      // Get diameter diff of two object_data.
      object_diff =
        abs(this_object_data.mi_diameter - other_object_data.mi_diameter);
      // Check diameter diff of two object_data.
      if (object_diff >= ROI_OBJECT_DETECT_DIAMETER_MIN) {
        if (PRINT_ROI_DETECTED_OBJECTS_ALL_DBG || PRINT_ROI_DETECTED_OBJECTS_ARE_SAME_DBG) println("ROI_Detected_Objects:are_same()"+":i="+i+":objects diameter diff="+(object_diff));
        return false;
      }

      // Get distance of two object_data.
      object_diff =
        get_points_distance(
          this_object_data.mi_center_x,
          this_object_data.mi_center_y,
          other_object_data.mi_center_x,
          other_object_data.mi_center_y);
      // Check distance of two object_data.
      if (object_diff >= ROI_OBJECT_DETECT_DIAMETER_MIN) {
        if (PRINT_ROI_DETECTED_OBJECTS_ALL_DBG || PRINT_ROI_DETECTED_OBJECTS_ARE_SAME_DBG) println("ROI_Detected_Objects:are_same()"+":i="+i+":objects distance="+object_diff);
        return false;
      }
    }
    //if (PRINT_ROI_DETECTED_OBJECTS_ALL_DBG || PRINT_ROI_DETECTED_OBJECTS_ARE_SAME_DBG) println("ROI_Detected_Objects:are_same()"+":same!");
    return true;
  }
}
